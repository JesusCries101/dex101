/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import { 
  ethers,
  EventFilter,
  Signer,
  PopulatedTransaction,
  Contract,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  CallOverrides,
} from "ethers";
import {
  BigNumber,
  BigNumberish,
} from '@ethersproject/bignumber'
import { BytesLike } from "@ethersproject/bytes";
import { Listener, Provider } from "@ethersproject/providers";
import { FunctionFragment, EventFragment, Result } from "@ethersproject/abi";
import { TypedEventFilter, TypedEvent, TypedListener } from "./commons";

interface ZeroExInterface extends ethers.utils.Interface {
  functions: {
    "_fillLimitOrder(tuple,tuple,uint128,address,address)": FunctionFragment;
    "_fillRfqOrder(tuple,tuple,uint128,address)": FunctionFragment;
    "_transformERC20(tuple)": FunctionFragment;
    "batchCancelLimitOrders(tuple[])": FunctionFragment;
    "batchCancelPairLimitOrders(address[],address[],uint256[])": FunctionFragment;
    "batchCancelPairRfqOrders(address[],address[],uint256[])": FunctionFragment;
    "batchCancelRfqOrders(tuple[])": FunctionFragment;
    "batchExecuteMetaTransactions(tuple[],tuple[])": FunctionFragment;
    "batchFill(tuple,uint256)": FunctionFragment;
    "batchFillLimitOrders(tuple[],tuple[],uint128[],bool)": FunctionFragment;
    "batchFillRfqOrders(tuple[],tuple[],uint128[],bool)": FunctionFragment;
    "batchGetLimitOrderRelevantStates(tuple[],tuple[])": FunctionFragment;
    "batchGetRfqOrderRelevantStates(tuple[],tuple[])": FunctionFragment;
    "cancelLimitOrder(tuple)": FunctionFragment;
    "cancelPairLimitOrders(address,address,uint256)": FunctionFragment;
    "cancelPairRfqOrders(address,address,uint256)": FunctionFragment;
    "cancelRfqOrder(tuple)": FunctionFragment;
    "createTransformWallet()": FunctionFragment;
    "executeMetaTransaction(tuple,tuple)": FunctionFragment;
    "extend(bytes4,address)": FunctionFragment;
    "fillLimitOrder(tuple,tuple,uint128)": FunctionFragment;
    "fillOrKillLimitOrder(tuple,tuple,uint128)": FunctionFragment;
    "fillOrKillRfqOrder(tuple,tuple,uint128)": FunctionFragment;
    "fillRfqOrder(tuple,tuple,uint128)": FunctionFragment;
    "getLimitOrderHash(tuple)": FunctionFragment;
    "getLimitOrderInfo(tuple)": FunctionFragment;
    "getLimitOrderRelevantState(tuple,tuple)": FunctionFragment;
    "getMetaTransactionExecutedBlock(tuple)": FunctionFragment;
    "getMetaTransactionHash(tuple)": FunctionFragment;
    "getMetaTransactionHashExecutedBlock(bytes32)": FunctionFragment;
    "getProtocolFeeMultiplier()": FunctionFragment;
    "getQuoteSigner()": FunctionFragment;
    "getRfqOrderHash(tuple)": FunctionFragment;
    "getRfqOrderInfo(tuple)": FunctionFragment;
    "getRfqOrderRelevantState(tuple,tuple)": FunctionFragment;
    "getRollbackEntryAtIndex(bytes4,uint256)": FunctionFragment;
    "getRollbackLength(bytes4)": FunctionFragment;
    "getTransformWallet()": FunctionFragment;
    "getTransformerDeployer()": FunctionFragment;
    "migrate(address,bytes,address)": FunctionFragment;
    "multiHopFill(tuple,uint256)": FunctionFragment;
    "owner()": FunctionFragment;
    "registerAllowedRfqOrigins(address[],bool)": FunctionFragment;
    "rollback(bytes4,address)": FunctionFragment;
    "sellToLiquidityProvider(address,address,address,address,uint256,uint256,bytes)": FunctionFragment;
    "sellToPancakeSwap(address[],uint256,uint256,uint8)": FunctionFragment;
    "sellToUniswap(address[],uint256,uint256,bool)": FunctionFragment;
    "setQuoteSigner(address)": FunctionFragment;
    "setTransformerDeployer(address)": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "transferProtocolFeesForPools(bytes32[])": FunctionFragment;
    "transformERC20(address,address,uint256,uint256,tuple[])": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "_fillLimitOrder",
    values: [
      {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      BigNumberish,
      string,
      string
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "_fillRfqOrder",
    values: [
      {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      BigNumberish,
      string
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "_transformERC20",
    values: [
      {
        taker: string;
        inputToken: string;
        outputToken: string;
        inputTokenAmount: BigNumberish;
        minOutputTokenAmount: BigNumberish;
        transformations: { deploymentNonce: BigNumberish; data: BytesLike }[];
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "batchCancelLimitOrders",
    values: [
      {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "batchCancelPairLimitOrders",
    values: [string[], string[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "batchCancelPairRfqOrders",
    values: [string[], string[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "batchCancelRfqOrders",
    values: [
      {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "batchExecuteMetaTransactions",
    values: [
      {
        signer: string;
        sender: string;
        minGasPrice: BigNumberish;
        maxGasPrice: BigNumberish;
        expirationTimeSeconds: BigNumberish;
        salt: BigNumberish;
        callData: BytesLike;
        value: BigNumberish;
        feeToken: string;
        feeAmount: BigNumberish;
      }[],
      {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "batchFill",
    values: [
      {
        inputToken: string;
        outputToken: string;
        sellAmount: BigNumberish;
        calls: {
          selector: BytesLike;
          sellAmount: BigNumberish;
          data: BytesLike;
        }[];
      },
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "batchFillLimitOrders",
    values: [
      {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      BigNumberish[],
      boolean
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "batchFillRfqOrders",
    values: [
      {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      BigNumberish[],
      boolean
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "batchGetLimitOrderRelevantStates",
    values: [
      {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "batchGetRfqOrderRelevantStates",
    values: [
      {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelLimitOrder",
    values: [
      {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelPairLimitOrders",
    values: [string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelPairRfqOrders",
    values: [string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelRfqOrder",
    values: [
      {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "createTransformWallet",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "executeMetaTransaction",
    values: [
      {
        signer: string;
        sender: string;
        minGasPrice: BigNumberish;
        maxGasPrice: BigNumberish;
        expirationTimeSeconds: BigNumberish;
        salt: BigNumberish;
        callData: BytesLike;
        value: BigNumberish;
        feeToken: string;
        feeAmount: BigNumberish;
      },
      {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "extend",
    values: [BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: "fillLimitOrder",
    values: [
      {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fillOrKillLimitOrder",
    values: [
      {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fillOrKillRfqOrder",
    values: [
      {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fillRfqOrder",
    values: [
      {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getLimitOrderHash",
    values: [
      {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getLimitOrderInfo",
    values: [
      {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getLimitOrderRelevantState",
    values: [
      {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getMetaTransactionExecutedBlock",
    values: [
      {
        signer: string;
        sender: string;
        minGasPrice: BigNumberish;
        maxGasPrice: BigNumberish;
        expirationTimeSeconds: BigNumberish;
        salt: BigNumberish;
        callData: BytesLike;
        value: BigNumberish;
        feeToken: string;
        feeAmount: BigNumberish;
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getMetaTransactionHash",
    values: [
      {
        signer: string;
        sender: string;
        minGasPrice: BigNumberish;
        maxGasPrice: BigNumberish;
        expirationTimeSeconds: BigNumberish;
        salt: BigNumberish;
        callData: BytesLike;
        value: BigNumberish;
        feeToken: string;
        feeAmount: BigNumberish;
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getMetaTransactionHashExecutedBlock",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getProtocolFeeMultiplier",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getQuoteSigner",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getRfqOrderHash",
    values: [
      {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getRfqOrderInfo",
    values: [
      {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getRfqOrderRelevantState",
    values: [
      {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getRollbackEntryAtIndex",
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getRollbackLength",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getTransformWallet",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getTransformerDeployer",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "migrate",
    values: [string, BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: "multiHopFill",
    values: [
      {
        tokens: string[];
        sellAmount: BigNumberish;
        calls: { selector: BytesLike; data: BytesLike }[];
      },
      BigNumberish
    ]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "registerAllowedRfqOrigins",
    values: [string[], boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "rollback",
    values: [BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: "sellToLiquidityProvider",
    values: [
      string,
      string,
      string,
      string,
      BigNumberish,
      BigNumberish,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "sellToPancakeSwap",
    values: [string[], BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "sellToUniswap",
    values: [string[], BigNumberish, BigNumberish, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "setQuoteSigner",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "setTransformerDeployer",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "transferProtocolFeesForPools",
    values: [BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "transformERC20",
    values: [
      string,
      string,
      BigNumberish,
      BigNumberish,
      { deploymentNonce: BigNumberish; data: BytesLike }[]
    ]
  ): string;

  decodeFunctionResult(
    functionFragment: "_fillLimitOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "_fillRfqOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "_transformERC20",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchCancelLimitOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchCancelPairLimitOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchCancelPairRfqOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchCancelRfqOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchExecuteMetaTransactions",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "batchFill", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "batchFillLimitOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchFillRfqOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchGetLimitOrderRelevantStates",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchGetRfqOrderRelevantStates",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelLimitOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelPairLimitOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelPairRfqOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelRfqOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createTransformWallet",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executeMetaTransaction",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "extend", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "fillLimitOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fillOrKillLimitOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fillOrKillRfqOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fillRfqOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getLimitOrderHash",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getLimitOrderInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getLimitOrderRelevantState",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getMetaTransactionExecutedBlock",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getMetaTransactionHash",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getMetaTransactionHashExecutedBlock",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getProtocolFeeMultiplier",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getQuoteSigner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getRfqOrderHash",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getRfqOrderInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getRfqOrderRelevantState",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getRollbackEntryAtIndex",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getRollbackLength",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTransformWallet",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTransformerDeployer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "migrate", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "multiHopFill",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "registerAllowedRfqOrigins",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "rollback", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "sellToLiquidityProvider",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "sellToPancakeSwap",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "sellToUniswap",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setQuoteSigner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setTransformerDeployer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferProtocolFeesForPools",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transformERC20",
    data: BytesLike
  ): Result;

  events: {
    "ExpiredRfqOrder(bytes32,address,uint64)": EventFragment;
    "LimitOrderFilled(bytes32,address,address,address,address,address,uint128,uint128,uint128,uint256,bytes32)": EventFragment;
    "LiquidityProviderSwap(address,address,uint256,uint256,address,address)": EventFragment;
    "MetaTransactionExecuted(bytes32,bytes4,address,address)": EventFragment;
    "Migrated(address,address,address)": EventFragment;
    "OrderCancelled(bytes32,address)": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
    "PairCancelledLimitOrders(address,address,address,uint256)": EventFragment;
    "PairCancelledRfqOrders(address,address,address,uint256)": EventFragment;
    "ProxyFunctionUpdated(bytes4,address,address)": EventFragment;
    "QuoteSignerUpdated(address)": EventFragment;
    "RfqOrderFilled(bytes32,address,address,address,address,uint128,uint128,bytes32)": EventFragment;
    "RfqOrderOriginsAllowed(address,address[],bool)": EventFragment;
    "TransformedERC20(address,address,address,uint256,uint256)": EventFragment;
    "TransformerDeployerUpdated(address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "ExpiredRfqOrder"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LimitOrderFilled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LiquidityProviderSwap"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MetaTransactionExecuted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Migrated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OrderCancelled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PairCancelledLimitOrders"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PairCancelledRfqOrders"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ProxyFunctionUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "QuoteSignerUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RfqOrderFilled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RfqOrderOriginsAllowed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TransformedERC20"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TransformerDeployerUpdated"): EventFragment;
}

export declare class ZeroEx extends Contract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  listeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter?: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): Array<TypedListener<EventArgsArray, EventArgsObject>>;
  off<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  on<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  once<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeListener<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeAllListeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): this;

  listeners(eventName?: string): Array<Listener>;
  off(eventName: string, listener: Listener): this;
  on(eventName: string, listener: Listener): this;
  once(eventName: string, listener: Listener): this;
  removeListener(eventName: string, listener: Listener): this;
  removeAllListeners(eventName?: string): this;

  queryFilter<EventArgsArray extends Array<any>, EventArgsObject>(
    event: TypedEventFilter<EventArgsArray, EventArgsObject>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEvent<EventArgsArray & EventArgsObject>>>;

  interface: ZeroExInterface;

  functions: {
    _fillLimitOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      taker: string,
      sender: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "_fillLimitOrder((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128,address,address)"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      taker: string,
      sender: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    _fillRfqOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      taker: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "_fillRfqOrder((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128,address)"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      taker: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    _transformERC20(
      args: {
        taker: string;
        inputToken: string;
        outputToken: string;
        inputTokenAmount: BigNumberish;
        minOutputTokenAmount: BigNumberish;
        transformations: { deploymentNonce: BigNumberish; data: BytesLike }[];
      },
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "_transformERC20((address,address,address,uint256,uint256,tuple[]))"(
      args: {
        taker: string;
        inputToken: string;
        outputToken: string;
        inputTokenAmount: BigNumberish;
        minOutputTokenAmount: BigNumberish;
        transformations: { deploymentNonce: BigNumberish; data: BytesLike }[];
      },
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    batchCancelLimitOrders(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "batchCancelLimitOrders(tuple[])"(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    batchCancelPairLimitOrders(
      makerTokens: string[],
      takerTokens: string[],
      minValidSalts: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "batchCancelPairLimitOrders(address[],address[],uint256[])"(
      makerTokens: string[],
      takerTokens: string[],
      minValidSalts: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    batchCancelPairRfqOrders(
      makerTokens: string[],
      takerTokens: string[],
      minValidSalts: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "batchCancelPairRfqOrders(address[],address[],uint256[])"(
      makerTokens: string[],
      takerTokens: string[],
      minValidSalts: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    batchCancelRfqOrders(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "batchCancelRfqOrders(tuple[])"(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    batchExecuteMetaTransactions(
      mtxs: {
        signer: string;
        sender: string;
        minGasPrice: BigNumberish;
        maxGasPrice: BigNumberish;
        expirationTimeSeconds: BigNumberish;
        salt: BigNumberish;
        callData: BytesLike;
        value: BigNumberish;
        feeToken: string;
        feeAmount: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "batchExecuteMetaTransactions(tuple[],tuple[])"(
      mtxs: {
        signer: string;
        sender: string;
        minGasPrice: BigNumberish;
        maxGasPrice: BigNumberish;
        expirationTimeSeconds: BigNumberish;
        salt: BigNumberish;
        callData: BytesLike;
        value: BigNumberish;
        feeToken: string;
        feeAmount: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    batchFill(
      fillData: {
        inputToken: string;
        outputToken: string;
        sellAmount: BigNumberish;
        calls: {
          selector: BytesLike;
          sellAmount: BigNumberish;
          data: BytesLike;
        }[];
      },
      minBuyAmount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "batchFill((address,address,uint256,tuple[]),uint256)"(
      fillData: {
        inputToken: string;
        outputToken: string;
        sellAmount: BigNumberish;
        calls: {
          selector: BytesLike;
          sellAmount: BigNumberish;
          data: BytesLike;
        }[];
      },
      minBuyAmount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    batchFillLimitOrders(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      takerTokenFillAmounts: BigNumberish[],
      revertIfIncomplete: boolean,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "batchFillLimitOrders(tuple[],tuple[],uint128[],bool)"(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      takerTokenFillAmounts: BigNumberish[],
      revertIfIncomplete: boolean,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    batchFillRfqOrders(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      takerTokenFillAmounts: BigNumberish[],
      revertIfIncomplete: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "batchFillRfqOrders(tuple[],tuple[],uint128[],bool)"(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      takerTokenFillAmounts: BigNumberish[],
      revertIfIncomplete: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    batchGetLimitOrderRelevantStates(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      overrides?: CallOverrides
    ): Promise<
      [
        ([string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        })[],
        BigNumber[],
        boolean[]
      ] & {
        orderInfos: ([string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        })[];
        actualFillableTakerTokenAmounts: BigNumber[];
        isSignatureValids: boolean[];
      }
    >;

    "batchGetLimitOrderRelevantStates(tuple[],tuple[])"(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      overrides?: CallOverrides
    ): Promise<
      [
        ([string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        })[],
        BigNumber[],
        boolean[]
      ] & {
        orderInfos: ([string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        })[];
        actualFillableTakerTokenAmounts: BigNumber[];
        isSignatureValids: boolean[];
      }
    >;

    batchGetRfqOrderRelevantStates(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      overrides?: CallOverrides
    ): Promise<
      [
        ([string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        })[],
        BigNumber[],
        boolean[]
      ] & {
        orderInfos: ([string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        })[];
        actualFillableTakerTokenAmounts: BigNumber[];
        isSignatureValids: boolean[];
      }
    >;

    "batchGetRfqOrderRelevantStates(tuple[],tuple[])"(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      overrides?: CallOverrides
    ): Promise<
      [
        ([string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        })[],
        BigNumber[],
        boolean[]
      ] & {
        orderInfos: ([string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        })[];
        actualFillableTakerTokenAmounts: BigNumber[];
        isSignatureValids: boolean[];
      }
    >;

    cancelLimitOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "cancelLimitOrder((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256))"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    cancelPairLimitOrders(
      makerToken: string,
      takerToken: string,
      minValidSalt: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "cancelPairLimitOrders(address,address,uint256)"(
      makerToken: string,
      takerToken: string,
      minValidSalt: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    cancelPairRfqOrders(
      makerToken: string,
      takerToken: string,
      minValidSalt: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "cancelPairRfqOrders(address,address,uint256)"(
      makerToken: string,
      takerToken: string,
      minValidSalt: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    cancelRfqOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "cancelRfqOrder((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256))"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    createTransformWallet(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "createTransformWallet()"(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    executeMetaTransaction(
      mtx: {
        signer: string;
        sender: string;
        minGasPrice: BigNumberish;
        maxGasPrice: BigNumberish;
        expirationTimeSeconds: BigNumberish;
        salt: BigNumberish;
        callData: BytesLike;
        value: BigNumberish;
        feeToken: string;
        feeAmount: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "executeMetaTransaction((address,address,uint256,uint256,uint256,uint256,bytes,uint256,address,uint256),(uint8,uint8,bytes32,bytes32))"(
      mtx: {
        signer: string;
        sender: string;
        minGasPrice: BigNumberish;
        maxGasPrice: BigNumberish;
        expirationTimeSeconds: BigNumberish;
        salt: BigNumberish;
        callData: BytesLike;
        value: BigNumberish;
        feeToken: string;
        feeAmount: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    extend(
      selector: BytesLike,
      impl: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "extend(bytes4,address)"(
      selector: BytesLike,
      impl: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    fillLimitOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "fillLimitOrder((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128)"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    fillOrKillLimitOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "fillOrKillLimitOrder((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128)"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    fillOrKillRfqOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "fillOrKillRfqOrder((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128)"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    fillRfqOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "fillRfqOrder((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128)"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    getLimitOrderHash(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<[string] & { orderHash: string }>;

    "getLimitOrderHash((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256))"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<[string] & { orderHash: string }>;

    getLimitOrderInfo(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<
      [
        [string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        }
      ] & {
        orderInfo: [string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        };
      }
    >;

    "getLimitOrderInfo((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256))"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<
      [
        [string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        }
      ] & {
        orderInfo: [string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        };
      }
    >;

    getLimitOrderRelevantState(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<
      [
        [string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        },
        BigNumber,
        boolean
      ] & {
        orderInfo: [string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        };
        actualFillableTakerTokenAmount: BigNumber;
        isSignatureValid: boolean;
      }
    >;

    "getLimitOrderRelevantState((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32))"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<
      [
        [string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        },
        BigNumber,
        boolean
      ] & {
        orderInfo: [string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        };
        actualFillableTakerTokenAmount: BigNumber;
        isSignatureValid: boolean;
      }
    >;

    getMetaTransactionExecutedBlock(
      mtx: {
        signer: string;
        sender: string;
        minGasPrice: BigNumberish;
        maxGasPrice: BigNumberish;
        expirationTimeSeconds: BigNumberish;
        salt: BigNumberish;
        callData: BytesLike;
        value: BigNumberish;
        feeToken: string;
        feeAmount: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { blockNumber: BigNumber }>;

    "getMetaTransactionExecutedBlock((address,address,uint256,uint256,uint256,uint256,bytes,uint256,address,uint256))"(
      mtx: {
        signer: string;
        sender: string;
        minGasPrice: BigNumberish;
        maxGasPrice: BigNumberish;
        expirationTimeSeconds: BigNumberish;
        salt: BigNumberish;
        callData: BytesLike;
        value: BigNumberish;
        feeToken: string;
        feeAmount: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { blockNumber: BigNumber }>;

    getMetaTransactionHash(
      mtx: {
        signer: string;
        sender: string;
        minGasPrice: BigNumberish;
        maxGasPrice: BigNumberish;
        expirationTimeSeconds: BigNumberish;
        salt: BigNumberish;
        callData: BytesLike;
        value: BigNumberish;
        feeToken: string;
        feeAmount: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<[string] & { mtxHash: string }>;

    "getMetaTransactionHash((address,address,uint256,uint256,uint256,uint256,bytes,uint256,address,uint256))"(
      mtx: {
        signer: string;
        sender: string;
        minGasPrice: BigNumberish;
        maxGasPrice: BigNumberish;
        expirationTimeSeconds: BigNumberish;
        salt: BigNumberish;
        callData: BytesLike;
        value: BigNumberish;
        feeToken: string;
        feeAmount: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<[string] & { mtxHash: string }>;

    getMetaTransactionHashExecutedBlock(
      mtxHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { blockNumber: BigNumber }>;

    "getMetaTransactionHashExecutedBlock(bytes32)"(
      mtxHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { blockNumber: BigNumber }>;

    getProtocolFeeMultiplier(
      overrides?: CallOverrides
    ): Promise<[number] & { multiplier: number }>;

    "getProtocolFeeMultiplier()"(
      overrides?: CallOverrides
    ): Promise<[number] & { multiplier: number }>;

    getQuoteSigner(
      overrides?: CallOverrides
    ): Promise<[string] & { signer: string }>;

    "getQuoteSigner()"(
      overrides?: CallOverrides
    ): Promise<[string] & { signer: string }>;

    getRfqOrderHash(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<[string] & { orderHash: string }>;

    "getRfqOrderHash((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256))"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<[string] & { orderHash: string }>;

    getRfqOrderInfo(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<
      [
        [string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        }
      ] & {
        orderInfo: [string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        };
      }
    >;

    "getRfqOrderInfo((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256))"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<
      [
        [string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        }
      ] & {
        orderInfo: [string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        };
      }
    >;

    getRfqOrderRelevantState(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<
      [
        [string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        },
        BigNumber,
        boolean
      ] & {
        orderInfo: [string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        };
        actualFillableTakerTokenAmount: BigNumber;
        isSignatureValid: boolean;
      }
    >;

    "getRfqOrderRelevantState((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32))"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<
      [
        [string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        },
        BigNumber,
        boolean
      ] & {
        orderInfo: [string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        };
        actualFillableTakerTokenAmount: BigNumber;
        isSignatureValid: boolean;
      }
    >;

    getRollbackEntryAtIndex(
      selector: BytesLike,
      idx: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string] & { impl: string }>;

    "getRollbackEntryAtIndex(bytes4,uint256)"(
      selector: BytesLike,
      idx: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string] & { impl: string }>;

    getRollbackLength(
      selector: BytesLike,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { rollbackLength: BigNumber }>;

    "getRollbackLength(bytes4)"(
      selector: BytesLike,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { rollbackLength: BigNumber }>;

    getTransformWallet(
      overrides?: CallOverrides
    ): Promise<[string] & { wallet: string }>;

    "getTransformWallet()"(
      overrides?: CallOverrides
    ): Promise<[string] & { wallet: string }>;

    getTransformerDeployer(
      overrides?: CallOverrides
    ): Promise<[string] & { deployer: string }>;

    "getTransformerDeployer()"(
      overrides?: CallOverrides
    ): Promise<[string] & { deployer: string }>;

    migrate(
      target: string,
      data: BytesLike,
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "migrate(address,bytes,address)"(
      target: string,
      data: BytesLike,
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    multiHopFill(
      fillData: {
        tokens: string[];
        sellAmount: BigNumberish;
        calls: { selector: BytesLike; data: BytesLike }[];
      },
      minBuyAmount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "multiHopFill((address[],uint256,tuple[]),uint256)"(
      fillData: {
        tokens: string[];
        sellAmount: BigNumberish;
        calls: { selector: BytesLike; data: BytesLike }[];
      },
      minBuyAmount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    owner(
      overrides?: CallOverrides
    ): Promise<[string] & { ownerAddress: string }>;

    "owner()"(
      overrides?: CallOverrides
    ): Promise<[string] & { ownerAddress: string }>;

    registerAllowedRfqOrigins(
      origins: string[],
      allowed: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "registerAllowedRfqOrigins(address[],bool)"(
      origins: string[],
      allowed: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    rollback(
      selector: BytesLike,
      targetImpl: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "rollback(bytes4,address)"(
      selector: BytesLike,
      targetImpl: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    sellToLiquidityProvider(
      inputToken: string,
      outputToken: string,
      provider: string,
      recipient: string,
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish,
      auxiliaryData: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "sellToLiquidityProvider(address,address,address,address,uint256,uint256,bytes)"(
      inputToken: string,
      outputToken: string,
      provider: string,
      recipient: string,
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish,
      auxiliaryData: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    sellToPancakeSwap(
      tokens: string[],
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish,
      fork: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "sellToPancakeSwap(address[],uint256,uint256,uint8)"(
      tokens: string[],
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish,
      fork: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    sellToUniswap(
      tokens: string[],
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish,
      isSushi: boolean,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "sellToUniswap(address[],uint256,uint256,bool)"(
      tokens: string[],
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish,
      isSushi: boolean,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setQuoteSigner(
      quoteSigner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "setQuoteSigner(address)"(
      quoteSigner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setTransformerDeployer(
      transformerDeployer: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "setTransformerDeployer(address)"(
      transformerDeployer: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "transferOwnership(address)"(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    transferProtocolFeesForPools(
      poolIds: BytesLike[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "transferProtocolFeesForPools(bytes32[])"(
      poolIds: BytesLike[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    transformERC20(
      inputToken: string,
      outputToken: string,
      inputTokenAmount: BigNumberish,
      minOutputTokenAmount: BigNumberish,
      transformations: { deploymentNonce: BigNumberish; data: BytesLike }[],
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "transformERC20(address,address,uint256,uint256,tuple[])"(
      inputToken: string,
      outputToken: string,
      inputTokenAmount: BigNumberish,
      minOutputTokenAmount: BigNumberish,
      transformations: { deploymentNonce: BigNumberish; data: BytesLike }[],
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  };

  _fillLimitOrder(
    order: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      takerTokenFeeAmount: BigNumberish;
      maker: string;
      taker: string;
      sender: string;
      feeRecipient: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    },
    signature: {
      signatureType: BigNumberish;
      v: BigNumberish;
      r: BytesLike;
      s: BytesLike;
    },
    takerTokenFillAmount: BigNumberish,
    taker: string,
    sender: string,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "_fillLimitOrder((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128,address,address)"(
    order: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      takerTokenFeeAmount: BigNumberish;
      maker: string;
      taker: string;
      sender: string;
      feeRecipient: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    },
    signature: {
      signatureType: BigNumberish;
      v: BigNumberish;
      r: BytesLike;
      s: BytesLike;
    },
    takerTokenFillAmount: BigNumberish,
    taker: string,
    sender: string,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  _fillRfqOrder(
    order: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      maker: string;
      taker: string;
      txOrigin: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    },
    signature: {
      signatureType: BigNumberish;
      v: BigNumberish;
      r: BytesLike;
      s: BytesLike;
    },
    takerTokenFillAmount: BigNumberish,
    taker: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "_fillRfqOrder((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128,address)"(
    order: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      maker: string;
      taker: string;
      txOrigin: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    },
    signature: {
      signatureType: BigNumberish;
      v: BigNumberish;
      r: BytesLike;
      s: BytesLike;
    },
    takerTokenFillAmount: BigNumberish,
    taker: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  _transformERC20(
    args: {
      taker: string;
      inputToken: string;
      outputToken: string;
      inputTokenAmount: BigNumberish;
      minOutputTokenAmount: BigNumberish;
      transformations: { deploymentNonce: BigNumberish; data: BytesLike }[];
    },
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "_transformERC20((address,address,address,uint256,uint256,tuple[]))"(
    args: {
      taker: string;
      inputToken: string;
      outputToken: string;
      inputTokenAmount: BigNumberish;
      minOutputTokenAmount: BigNumberish;
      transformations: { deploymentNonce: BigNumberish; data: BytesLike }[];
    },
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  batchCancelLimitOrders(
    orders: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      takerTokenFeeAmount: BigNumberish;
      maker: string;
      taker: string;
      sender: string;
      feeRecipient: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    }[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "batchCancelLimitOrders(tuple[])"(
    orders: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      takerTokenFeeAmount: BigNumberish;
      maker: string;
      taker: string;
      sender: string;
      feeRecipient: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    }[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  batchCancelPairLimitOrders(
    makerTokens: string[],
    takerTokens: string[],
    minValidSalts: BigNumberish[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "batchCancelPairLimitOrders(address[],address[],uint256[])"(
    makerTokens: string[],
    takerTokens: string[],
    minValidSalts: BigNumberish[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  batchCancelPairRfqOrders(
    makerTokens: string[],
    takerTokens: string[],
    minValidSalts: BigNumberish[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "batchCancelPairRfqOrders(address[],address[],uint256[])"(
    makerTokens: string[],
    takerTokens: string[],
    minValidSalts: BigNumberish[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  batchCancelRfqOrders(
    orders: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      maker: string;
      taker: string;
      txOrigin: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    }[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "batchCancelRfqOrders(tuple[])"(
    orders: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      maker: string;
      taker: string;
      txOrigin: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    }[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  batchExecuteMetaTransactions(
    mtxs: {
      signer: string;
      sender: string;
      minGasPrice: BigNumberish;
      maxGasPrice: BigNumberish;
      expirationTimeSeconds: BigNumberish;
      salt: BigNumberish;
      callData: BytesLike;
      value: BigNumberish;
      feeToken: string;
      feeAmount: BigNumberish;
    }[],
    signatures: {
      signatureType: BigNumberish;
      v: BigNumberish;
      r: BytesLike;
      s: BytesLike;
    }[],
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "batchExecuteMetaTransactions(tuple[],tuple[])"(
    mtxs: {
      signer: string;
      sender: string;
      minGasPrice: BigNumberish;
      maxGasPrice: BigNumberish;
      expirationTimeSeconds: BigNumberish;
      salt: BigNumberish;
      callData: BytesLike;
      value: BigNumberish;
      feeToken: string;
      feeAmount: BigNumberish;
    }[],
    signatures: {
      signatureType: BigNumberish;
      v: BigNumberish;
      r: BytesLike;
      s: BytesLike;
    }[],
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  batchFill(
    fillData: {
      inputToken: string;
      outputToken: string;
      sellAmount: BigNumberish;
      calls: {
        selector: BytesLike;
        sellAmount: BigNumberish;
        data: BytesLike;
      }[];
    },
    minBuyAmount: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "batchFill((address,address,uint256,tuple[]),uint256)"(
    fillData: {
      inputToken: string;
      outputToken: string;
      sellAmount: BigNumberish;
      calls: {
        selector: BytesLike;
        sellAmount: BigNumberish;
        data: BytesLike;
      }[];
    },
    minBuyAmount: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  batchFillLimitOrders(
    orders: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      takerTokenFeeAmount: BigNumberish;
      maker: string;
      taker: string;
      sender: string;
      feeRecipient: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    }[],
    signatures: {
      signatureType: BigNumberish;
      v: BigNumberish;
      r: BytesLike;
      s: BytesLike;
    }[],
    takerTokenFillAmounts: BigNumberish[],
    revertIfIncomplete: boolean,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "batchFillLimitOrders(tuple[],tuple[],uint128[],bool)"(
    orders: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      takerTokenFeeAmount: BigNumberish;
      maker: string;
      taker: string;
      sender: string;
      feeRecipient: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    }[],
    signatures: {
      signatureType: BigNumberish;
      v: BigNumberish;
      r: BytesLike;
      s: BytesLike;
    }[],
    takerTokenFillAmounts: BigNumberish[],
    revertIfIncomplete: boolean,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  batchFillRfqOrders(
    orders: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      maker: string;
      taker: string;
      txOrigin: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    }[],
    signatures: {
      signatureType: BigNumberish;
      v: BigNumberish;
      r: BytesLike;
      s: BytesLike;
    }[],
    takerTokenFillAmounts: BigNumberish[],
    revertIfIncomplete: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "batchFillRfqOrders(tuple[],tuple[],uint128[],bool)"(
    orders: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      maker: string;
      taker: string;
      txOrigin: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    }[],
    signatures: {
      signatureType: BigNumberish;
      v: BigNumberish;
      r: BytesLike;
      s: BytesLike;
    }[],
    takerTokenFillAmounts: BigNumberish[],
    revertIfIncomplete: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  batchGetLimitOrderRelevantStates(
    orders: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      takerTokenFeeAmount: BigNumberish;
      maker: string;
      taker: string;
      sender: string;
      feeRecipient: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    }[],
    signatures: {
      signatureType: BigNumberish;
      v: BigNumberish;
      r: BytesLike;
      s: BytesLike;
    }[],
    overrides?: CallOverrides
  ): Promise<
    [
      ([string, number, BigNumber] & {
        orderHash: string;
        status: number;
        takerTokenFilledAmount: BigNumber;
      })[],
      BigNumber[],
      boolean[]
    ] & {
      orderInfos: ([string, number, BigNumber] & {
        orderHash: string;
        status: number;
        takerTokenFilledAmount: BigNumber;
      })[];
      actualFillableTakerTokenAmounts: BigNumber[];
      isSignatureValids: boolean[];
    }
  >;

  "batchGetLimitOrderRelevantStates(tuple[],tuple[])"(
    orders: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      takerTokenFeeAmount: BigNumberish;
      maker: string;
      taker: string;
      sender: string;
      feeRecipient: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    }[],
    signatures: {
      signatureType: BigNumberish;
      v: BigNumberish;
      r: BytesLike;
      s: BytesLike;
    }[],
    overrides?: CallOverrides
  ): Promise<
    [
      ([string, number, BigNumber] & {
        orderHash: string;
        status: number;
        takerTokenFilledAmount: BigNumber;
      })[],
      BigNumber[],
      boolean[]
    ] & {
      orderInfos: ([string, number, BigNumber] & {
        orderHash: string;
        status: number;
        takerTokenFilledAmount: BigNumber;
      })[];
      actualFillableTakerTokenAmounts: BigNumber[];
      isSignatureValids: boolean[];
    }
  >;

  batchGetRfqOrderRelevantStates(
    orders: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      maker: string;
      taker: string;
      txOrigin: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    }[],
    signatures: {
      signatureType: BigNumberish;
      v: BigNumberish;
      r: BytesLike;
      s: BytesLike;
    }[],
    overrides?: CallOverrides
  ): Promise<
    [
      ([string, number, BigNumber] & {
        orderHash: string;
        status: number;
        takerTokenFilledAmount: BigNumber;
      })[],
      BigNumber[],
      boolean[]
    ] & {
      orderInfos: ([string, number, BigNumber] & {
        orderHash: string;
        status: number;
        takerTokenFilledAmount: BigNumber;
      })[];
      actualFillableTakerTokenAmounts: BigNumber[];
      isSignatureValids: boolean[];
    }
  >;

  "batchGetRfqOrderRelevantStates(tuple[],tuple[])"(
    orders: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      maker: string;
      taker: string;
      txOrigin: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    }[],
    signatures: {
      signatureType: BigNumberish;
      v: BigNumberish;
      r: BytesLike;
      s: BytesLike;
    }[],
    overrides?: CallOverrides
  ): Promise<
    [
      ([string, number, BigNumber] & {
        orderHash: string;
        status: number;
        takerTokenFilledAmount: BigNumber;
      })[],
      BigNumber[],
      boolean[]
    ] & {
      orderInfos: ([string, number, BigNumber] & {
        orderHash: string;
        status: number;
        takerTokenFilledAmount: BigNumber;
      })[];
      actualFillableTakerTokenAmounts: BigNumber[];
      isSignatureValids: boolean[];
    }
  >;

  cancelLimitOrder(
    order: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      takerTokenFeeAmount: BigNumberish;
      maker: string;
      taker: string;
      sender: string;
      feeRecipient: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    },
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "cancelLimitOrder((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256))"(
    order: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      takerTokenFeeAmount: BigNumberish;
      maker: string;
      taker: string;
      sender: string;
      feeRecipient: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    },
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  cancelPairLimitOrders(
    makerToken: string,
    takerToken: string,
    minValidSalt: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "cancelPairLimitOrders(address,address,uint256)"(
    makerToken: string,
    takerToken: string,
    minValidSalt: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  cancelPairRfqOrders(
    makerToken: string,
    takerToken: string,
    minValidSalt: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "cancelPairRfqOrders(address,address,uint256)"(
    makerToken: string,
    takerToken: string,
    minValidSalt: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  cancelRfqOrder(
    order: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      maker: string;
      taker: string;
      txOrigin: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    },
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "cancelRfqOrder((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256))"(
    order: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      maker: string;
      taker: string;
      txOrigin: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    },
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  createTransformWallet(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "createTransformWallet()"(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  executeMetaTransaction(
    mtx: {
      signer: string;
      sender: string;
      minGasPrice: BigNumberish;
      maxGasPrice: BigNumberish;
      expirationTimeSeconds: BigNumberish;
      salt: BigNumberish;
      callData: BytesLike;
      value: BigNumberish;
      feeToken: string;
      feeAmount: BigNumberish;
    },
    signature: {
      signatureType: BigNumberish;
      v: BigNumberish;
      r: BytesLike;
      s: BytesLike;
    },
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "executeMetaTransaction((address,address,uint256,uint256,uint256,uint256,bytes,uint256,address,uint256),(uint8,uint8,bytes32,bytes32))"(
    mtx: {
      signer: string;
      sender: string;
      minGasPrice: BigNumberish;
      maxGasPrice: BigNumberish;
      expirationTimeSeconds: BigNumberish;
      salt: BigNumberish;
      callData: BytesLike;
      value: BigNumberish;
      feeToken: string;
      feeAmount: BigNumberish;
    },
    signature: {
      signatureType: BigNumberish;
      v: BigNumberish;
      r: BytesLike;
      s: BytesLike;
    },
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  extend(
    selector: BytesLike,
    impl: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "extend(bytes4,address)"(
    selector: BytesLike,
    impl: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  fillLimitOrder(
    order: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      takerTokenFeeAmount: BigNumberish;
      maker: string;
      taker: string;
      sender: string;
      feeRecipient: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    },
    signature: {
      signatureType: BigNumberish;
      v: BigNumberish;
      r: BytesLike;
      s: BytesLike;
    },
    takerTokenFillAmount: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "fillLimitOrder((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128)"(
    order: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      takerTokenFeeAmount: BigNumberish;
      maker: string;
      taker: string;
      sender: string;
      feeRecipient: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    },
    signature: {
      signatureType: BigNumberish;
      v: BigNumberish;
      r: BytesLike;
      s: BytesLike;
    },
    takerTokenFillAmount: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  fillOrKillLimitOrder(
    order: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      takerTokenFeeAmount: BigNumberish;
      maker: string;
      taker: string;
      sender: string;
      feeRecipient: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    },
    signature: {
      signatureType: BigNumberish;
      v: BigNumberish;
      r: BytesLike;
      s: BytesLike;
    },
    takerTokenFillAmount: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "fillOrKillLimitOrder((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128)"(
    order: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      takerTokenFeeAmount: BigNumberish;
      maker: string;
      taker: string;
      sender: string;
      feeRecipient: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    },
    signature: {
      signatureType: BigNumberish;
      v: BigNumberish;
      r: BytesLike;
      s: BytesLike;
    },
    takerTokenFillAmount: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  fillOrKillRfqOrder(
    order: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      maker: string;
      taker: string;
      txOrigin: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    },
    signature: {
      signatureType: BigNumberish;
      v: BigNumberish;
      r: BytesLike;
      s: BytesLike;
    },
    takerTokenFillAmount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "fillOrKillRfqOrder((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128)"(
    order: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      maker: string;
      taker: string;
      txOrigin: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    },
    signature: {
      signatureType: BigNumberish;
      v: BigNumberish;
      r: BytesLike;
      s: BytesLike;
    },
    takerTokenFillAmount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  fillRfqOrder(
    order: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      maker: string;
      taker: string;
      txOrigin: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    },
    signature: {
      signatureType: BigNumberish;
      v: BigNumberish;
      r: BytesLike;
      s: BytesLike;
    },
    takerTokenFillAmount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "fillRfqOrder((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128)"(
    order: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      maker: string;
      taker: string;
      txOrigin: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    },
    signature: {
      signatureType: BigNumberish;
      v: BigNumberish;
      r: BytesLike;
      s: BytesLike;
    },
    takerTokenFillAmount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  getLimitOrderHash(
    order: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      takerTokenFeeAmount: BigNumberish;
      maker: string;
      taker: string;
      sender: string;
      feeRecipient: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    },
    overrides?: CallOverrides
  ): Promise<string>;

  "getLimitOrderHash((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256))"(
    order: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      takerTokenFeeAmount: BigNumberish;
      maker: string;
      taker: string;
      sender: string;
      feeRecipient: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    },
    overrides?: CallOverrides
  ): Promise<string>;

  getLimitOrderInfo(
    order: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      takerTokenFeeAmount: BigNumberish;
      maker: string;
      taker: string;
      sender: string;
      feeRecipient: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    },
    overrides?: CallOverrides
  ): Promise<
    [string, number, BigNumber] & {
      orderHash: string;
      status: number;
      takerTokenFilledAmount: BigNumber;
    }
  >;

  "getLimitOrderInfo((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256))"(
    order: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      takerTokenFeeAmount: BigNumberish;
      maker: string;
      taker: string;
      sender: string;
      feeRecipient: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    },
    overrides?: CallOverrides
  ): Promise<
    [string, number, BigNumber] & {
      orderHash: string;
      status: number;
      takerTokenFilledAmount: BigNumber;
    }
  >;

  getLimitOrderRelevantState(
    order: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      takerTokenFeeAmount: BigNumberish;
      maker: string;
      taker: string;
      sender: string;
      feeRecipient: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    },
    signature: {
      signatureType: BigNumberish;
      v: BigNumberish;
      r: BytesLike;
      s: BytesLike;
    },
    overrides?: CallOverrides
  ): Promise<
    [
      [string, number, BigNumber] & {
        orderHash: string;
        status: number;
        takerTokenFilledAmount: BigNumber;
      },
      BigNumber,
      boolean
    ] & {
      orderInfo: [string, number, BigNumber] & {
        orderHash: string;
        status: number;
        takerTokenFilledAmount: BigNumber;
      };
      actualFillableTakerTokenAmount: BigNumber;
      isSignatureValid: boolean;
    }
  >;

  "getLimitOrderRelevantState((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32))"(
    order: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      takerTokenFeeAmount: BigNumberish;
      maker: string;
      taker: string;
      sender: string;
      feeRecipient: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    },
    signature: {
      signatureType: BigNumberish;
      v: BigNumberish;
      r: BytesLike;
      s: BytesLike;
    },
    overrides?: CallOverrides
  ): Promise<
    [
      [string, number, BigNumber] & {
        orderHash: string;
        status: number;
        takerTokenFilledAmount: BigNumber;
      },
      BigNumber,
      boolean
    ] & {
      orderInfo: [string, number, BigNumber] & {
        orderHash: string;
        status: number;
        takerTokenFilledAmount: BigNumber;
      };
      actualFillableTakerTokenAmount: BigNumber;
      isSignatureValid: boolean;
    }
  >;

  getMetaTransactionExecutedBlock(
    mtx: {
      signer: string;
      sender: string;
      minGasPrice: BigNumberish;
      maxGasPrice: BigNumberish;
      expirationTimeSeconds: BigNumberish;
      salt: BigNumberish;
      callData: BytesLike;
      value: BigNumberish;
      feeToken: string;
      feeAmount: BigNumberish;
    },
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "getMetaTransactionExecutedBlock((address,address,uint256,uint256,uint256,uint256,bytes,uint256,address,uint256))"(
    mtx: {
      signer: string;
      sender: string;
      minGasPrice: BigNumberish;
      maxGasPrice: BigNumberish;
      expirationTimeSeconds: BigNumberish;
      salt: BigNumberish;
      callData: BytesLike;
      value: BigNumberish;
      feeToken: string;
      feeAmount: BigNumberish;
    },
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getMetaTransactionHash(
    mtx: {
      signer: string;
      sender: string;
      minGasPrice: BigNumberish;
      maxGasPrice: BigNumberish;
      expirationTimeSeconds: BigNumberish;
      salt: BigNumberish;
      callData: BytesLike;
      value: BigNumberish;
      feeToken: string;
      feeAmount: BigNumberish;
    },
    overrides?: CallOverrides
  ): Promise<string>;

  "getMetaTransactionHash((address,address,uint256,uint256,uint256,uint256,bytes,uint256,address,uint256))"(
    mtx: {
      signer: string;
      sender: string;
      minGasPrice: BigNumberish;
      maxGasPrice: BigNumberish;
      expirationTimeSeconds: BigNumberish;
      salt: BigNumberish;
      callData: BytesLike;
      value: BigNumberish;
      feeToken: string;
      feeAmount: BigNumberish;
    },
    overrides?: CallOverrides
  ): Promise<string>;

  getMetaTransactionHashExecutedBlock(
    mtxHash: BytesLike,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "getMetaTransactionHashExecutedBlock(bytes32)"(
    mtxHash: BytesLike,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getProtocolFeeMultiplier(overrides?: CallOverrides): Promise<number>;

  "getProtocolFeeMultiplier()"(overrides?: CallOverrides): Promise<number>;

  getQuoteSigner(overrides?: CallOverrides): Promise<string>;

  "getQuoteSigner()"(overrides?: CallOverrides): Promise<string>;

  getRfqOrderHash(
    order: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      maker: string;
      taker: string;
      txOrigin: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    },
    overrides?: CallOverrides
  ): Promise<string>;

  "getRfqOrderHash((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256))"(
    order: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      maker: string;
      taker: string;
      txOrigin: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    },
    overrides?: CallOverrides
  ): Promise<string>;

  getRfqOrderInfo(
    order: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      maker: string;
      taker: string;
      txOrigin: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    },
    overrides?: CallOverrides
  ): Promise<
    [string, number, BigNumber] & {
      orderHash: string;
      status: number;
      takerTokenFilledAmount: BigNumber;
    }
  >;

  "getRfqOrderInfo((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256))"(
    order: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      maker: string;
      taker: string;
      txOrigin: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    },
    overrides?: CallOverrides
  ): Promise<
    [string, number, BigNumber] & {
      orderHash: string;
      status: number;
      takerTokenFilledAmount: BigNumber;
    }
  >;

  getRfqOrderRelevantState(
    order: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      maker: string;
      taker: string;
      txOrigin: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    },
    signature: {
      signatureType: BigNumberish;
      v: BigNumberish;
      r: BytesLike;
      s: BytesLike;
    },
    overrides?: CallOverrides
  ): Promise<
    [
      [string, number, BigNumber] & {
        orderHash: string;
        status: number;
        takerTokenFilledAmount: BigNumber;
      },
      BigNumber,
      boolean
    ] & {
      orderInfo: [string, number, BigNumber] & {
        orderHash: string;
        status: number;
        takerTokenFilledAmount: BigNumber;
      };
      actualFillableTakerTokenAmount: BigNumber;
      isSignatureValid: boolean;
    }
  >;

  "getRfqOrderRelevantState((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32))"(
    order: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      maker: string;
      taker: string;
      txOrigin: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    },
    signature: {
      signatureType: BigNumberish;
      v: BigNumberish;
      r: BytesLike;
      s: BytesLike;
    },
    overrides?: CallOverrides
  ): Promise<
    [
      [string, number, BigNumber] & {
        orderHash: string;
        status: number;
        takerTokenFilledAmount: BigNumber;
      },
      BigNumber,
      boolean
    ] & {
      orderInfo: [string, number, BigNumber] & {
        orderHash: string;
        status: number;
        takerTokenFilledAmount: BigNumber;
      };
      actualFillableTakerTokenAmount: BigNumber;
      isSignatureValid: boolean;
    }
  >;

  getRollbackEntryAtIndex(
    selector: BytesLike,
    idx: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>;

  "getRollbackEntryAtIndex(bytes4,uint256)"(
    selector: BytesLike,
    idx: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>;

  getRollbackLength(
    selector: BytesLike,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "getRollbackLength(bytes4)"(
    selector: BytesLike,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getTransformWallet(overrides?: CallOverrides): Promise<string>;

  "getTransformWallet()"(overrides?: CallOverrides): Promise<string>;

  getTransformerDeployer(overrides?: CallOverrides): Promise<string>;

  "getTransformerDeployer()"(overrides?: CallOverrides): Promise<string>;

  migrate(
    target: string,
    data: BytesLike,
    newOwner: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "migrate(address,bytes,address)"(
    target: string,
    data: BytesLike,
    newOwner: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  multiHopFill(
    fillData: {
      tokens: string[];
      sellAmount: BigNumberish;
      calls: { selector: BytesLike; data: BytesLike }[];
    },
    minBuyAmount: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "multiHopFill((address[],uint256,tuple[]),uint256)"(
    fillData: {
      tokens: string[];
      sellAmount: BigNumberish;
      calls: { selector: BytesLike; data: BytesLike }[];
    },
    minBuyAmount: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  owner(overrides?: CallOverrides): Promise<string>;

  "owner()"(overrides?: CallOverrides): Promise<string>;

  registerAllowedRfqOrigins(
    origins: string[],
    allowed: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "registerAllowedRfqOrigins(address[],bool)"(
    origins: string[],
    allowed: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  rollback(
    selector: BytesLike,
    targetImpl: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "rollback(bytes4,address)"(
    selector: BytesLike,
    targetImpl: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  sellToLiquidityProvider(
    inputToken: string,
    outputToken: string,
    provider: string,
    recipient: string,
    sellAmount: BigNumberish,
    minBuyAmount: BigNumberish,
    auxiliaryData: BytesLike,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "sellToLiquidityProvider(address,address,address,address,uint256,uint256,bytes)"(
    inputToken: string,
    outputToken: string,
    provider: string,
    recipient: string,
    sellAmount: BigNumberish,
    minBuyAmount: BigNumberish,
    auxiliaryData: BytesLike,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  sellToPancakeSwap(
    tokens: string[],
    sellAmount: BigNumberish,
    minBuyAmount: BigNumberish,
    fork: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "sellToPancakeSwap(address[],uint256,uint256,uint8)"(
    tokens: string[],
    sellAmount: BigNumberish,
    minBuyAmount: BigNumberish,
    fork: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  sellToUniswap(
    tokens: string[],
    sellAmount: BigNumberish,
    minBuyAmount: BigNumberish,
    isSushi: boolean,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "sellToUniswap(address[],uint256,uint256,bool)"(
    tokens: string[],
    sellAmount: BigNumberish,
    minBuyAmount: BigNumberish,
    isSushi: boolean,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  setQuoteSigner(
    quoteSigner: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "setQuoteSigner(address)"(
    quoteSigner: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  setTransformerDeployer(
    transformerDeployer: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "setTransformerDeployer(address)"(
    transformerDeployer: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  transferOwnership(
    newOwner: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "transferOwnership(address)"(
    newOwner: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  transferProtocolFeesForPools(
    poolIds: BytesLike[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "transferProtocolFeesForPools(bytes32[])"(
    poolIds: BytesLike[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  transformERC20(
    inputToken: string,
    outputToken: string,
    inputTokenAmount: BigNumberish,
    minOutputTokenAmount: BigNumberish,
    transformations: { deploymentNonce: BigNumberish; data: BytesLike }[],
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "transformERC20(address,address,uint256,uint256,tuple[])"(
    inputToken: string,
    outputToken: string,
    inputTokenAmount: BigNumberish,
    minOutputTokenAmount: BigNumberish,
    transformations: { deploymentNonce: BigNumberish; data: BytesLike }[],
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    _fillLimitOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      taker: string,
      sender: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        takerTokenFilledAmount: BigNumber;
        makerTokenFilledAmount: BigNumber;
      }
    >;

    "_fillLimitOrder((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128,address,address)"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      taker: string,
      sender: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        takerTokenFilledAmount: BigNumber;
        makerTokenFilledAmount: BigNumber;
      }
    >;

    _fillRfqOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      taker: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        takerTokenFilledAmount: BigNumber;
        makerTokenFilledAmount: BigNumber;
      }
    >;

    "_fillRfqOrder((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128,address)"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      taker: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        takerTokenFilledAmount: BigNumber;
        makerTokenFilledAmount: BigNumber;
      }
    >;

    _transformERC20(
      args: {
        taker: string;
        inputToken: string;
        outputToken: string;
        inputTokenAmount: BigNumberish;
        minOutputTokenAmount: BigNumberish;
        transformations: { deploymentNonce: BigNumberish; data: BytesLike }[];
      },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "_transformERC20((address,address,address,uint256,uint256,tuple[]))"(
      args: {
        taker: string;
        inputToken: string;
        outputToken: string;
        inputTokenAmount: BigNumberish;
        minOutputTokenAmount: BigNumberish;
        transformations: { deploymentNonce: BigNumberish; data: BytesLike }[];
      },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    batchCancelLimitOrders(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      overrides?: CallOverrides
    ): Promise<void>;

    "batchCancelLimitOrders(tuple[])"(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      overrides?: CallOverrides
    ): Promise<void>;

    batchCancelPairLimitOrders(
      makerTokens: string[],
      takerTokens: string[],
      minValidSalts: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<void>;

    "batchCancelPairLimitOrders(address[],address[],uint256[])"(
      makerTokens: string[],
      takerTokens: string[],
      minValidSalts: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<void>;

    batchCancelPairRfqOrders(
      makerTokens: string[],
      takerTokens: string[],
      minValidSalts: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<void>;

    "batchCancelPairRfqOrders(address[],address[],uint256[])"(
      makerTokens: string[],
      takerTokens: string[],
      minValidSalts: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<void>;

    batchCancelRfqOrders(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      overrides?: CallOverrides
    ): Promise<void>;

    "batchCancelRfqOrders(tuple[])"(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      overrides?: CallOverrides
    ): Promise<void>;

    batchExecuteMetaTransactions(
      mtxs: {
        signer: string;
        sender: string;
        minGasPrice: BigNumberish;
        maxGasPrice: BigNumberish;
        expirationTimeSeconds: BigNumberish;
        salt: BigNumberish;
        callData: BytesLike;
        value: BigNumberish;
        feeToken: string;
        feeAmount: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      overrides?: CallOverrides
    ): Promise<string[]>;

    "batchExecuteMetaTransactions(tuple[],tuple[])"(
      mtxs: {
        signer: string;
        sender: string;
        minGasPrice: BigNumberish;
        maxGasPrice: BigNumberish;
        expirationTimeSeconds: BigNumberish;
        salt: BigNumberish;
        callData: BytesLike;
        value: BigNumberish;
        feeToken: string;
        feeAmount: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      overrides?: CallOverrides
    ): Promise<string[]>;

    batchFill(
      fillData: {
        inputToken: string;
        outputToken: string;
        sellAmount: BigNumberish;
        calls: {
          selector: BytesLike;
          sellAmount: BigNumberish;
          data: BytesLike;
        }[];
      },
      minBuyAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "batchFill((address,address,uint256,tuple[]),uint256)"(
      fillData: {
        inputToken: string;
        outputToken: string;
        sellAmount: BigNumberish;
        calls: {
          selector: BytesLike;
          sellAmount: BigNumberish;
          data: BytesLike;
        }[];
      },
      minBuyAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    batchFillLimitOrders(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      takerTokenFillAmounts: BigNumberish[],
      revertIfIncomplete: boolean,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber[], BigNumber[]] & {
        takerTokenFilledAmounts: BigNumber[];
        makerTokenFilledAmounts: BigNumber[];
      }
    >;

    "batchFillLimitOrders(tuple[],tuple[],uint128[],bool)"(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      takerTokenFillAmounts: BigNumberish[],
      revertIfIncomplete: boolean,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber[], BigNumber[]] & {
        takerTokenFilledAmounts: BigNumber[];
        makerTokenFilledAmounts: BigNumber[];
      }
    >;

    batchFillRfqOrders(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      takerTokenFillAmounts: BigNumberish[],
      revertIfIncomplete: boolean,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber[], BigNumber[]] & {
        takerTokenFilledAmounts: BigNumber[];
        makerTokenFilledAmounts: BigNumber[];
      }
    >;

    "batchFillRfqOrders(tuple[],tuple[],uint128[],bool)"(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      takerTokenFillAmounts: BigNumberish[],
      revertIfIncomplete: boolean,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber[], BigNumber[]] & {
        takerTokenFilledAmounts: BigNumber[];
        makerTokenFilledAmounts: BigNumber[];
      }
    >;

    batchGetLimitOrderRelevantStates(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      overrides?: CallOverrides
    ): Promise<
      [
        ([string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        })[],
        BigNumber[],
        boolean[]
      ] & {
        orderInfos: ([string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        })[];
        actualFillableTakerTokenAmounts: BigNumber[];
        isSignatureValids: boolean[];
      }
    >;

    "batchGetLimitOrderRelevantStates(tuple[],tuple[])"(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      overrides?: CallOverrides
    ): Promise<
      [
        ([string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        })[],
        BigNumber[],
        boolean[]
      ] & {
        orderInfos: ([string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        })[];
        actualFillableTakerTokenAmounts: BigNumber[];
        isSignatureValids: boolean[];
      }
    >;

    batchGetRfqOrderRelevantStates(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      overrides?: CallOverrides
    ): Promise<
      [
        ([string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        })[],
        BigNumber[],
        boolean[]
      ] & {
        orderInfos: ([string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        })[];
        actualFillableTakerTokenAmounts: BigNumber[];
        isSignatureValids: boolean[];
      }
    >;

    "batchGetRfqOrderRelevantStates(tuple[],tuple[])"(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      overrides?: CallOverrides
    ): Promise<
      [
        ([string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        })[],
        BigNumber[],
        boolean[]
      ] & {
        orderInfos: ([string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        })[];
        actualFillableTakerTokenAmounts: BigNumber[];
        isSignatureValids: boolean[];
      }
    >;

    cancelLimitOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<void>;

    "cancelLimitOrder((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256))"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<void>;

    cancelPairLimitOrders(
      makerToken: string,
      takerToken: string,
      minValidSalt: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "cancelPairLimitOrders(address,address,uint256)"(
      makerToken: string,
      takerToken: string,
      minValidSalt: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    cancelPairRfqOrders(
      makerToken: string,
      takerToken: string,
      minValidSalt: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "cancelPairRfqOrders(address,address,uint256)"(
      makerToken: string,
      takerToken: string,
      minValidSalt: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    cancelRfqOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<void>;

    "cancelRfqOrder((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256))"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<void>;

    createTransformWallet(overrides?: CallOverrides): Promise<string>;

    "createTransformWallet()"(overrides?: CallOverrides): Promise<string>;

    executeMetaTransaction(
      mtx: {
        signer: string;
        sender: string;
        minGasPrice: BigNumberish;
        maxGasPrice: BigNumberish;
        expirationTimeSeconds: BigNumberish;
        salt: BigNumberish;
        callData: BytesLike;
        value: BigNumberish;
        feeToken: string;
        feeAmount: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<string>;

    "executeMetaTransaction((address,address,uint256,uint256,uint256,uint256,bytes,uint256,address,uint256),(uint8,uint8,bytes32,bytes32))"(
      mtx: {
        signer: string;
        sender: string;
        minGasPrice: BigNumberish;
        maxGasPrice: BigNumberish;
        expirationTimeSeconds: BigNumberish;
        salt: BigNumberish;
        callData: BytesLike;
        value: BigNumberish;
        feeToken: string;
        feeAmount: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<string>;

    extend(
      selector: BytesLike,
      impl: string,
      overrides?: CallOverrides
    ): Promise<void>;

    "extend(bytes4,address)"(
      selector: BytesLike,
      impl: string,
      overrides?: CallOverrides
    ): Promise<void>;

    fillLimitOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        takerTokenFilledAmount: BigNumber;
        makerTokenFilledAmount: BigNumber;
      }
    >;

    "fillLimitOrder((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128)"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        takerTokenFilledAmount: BigNumber;
        makerTokenFilledAmount: BigNumber;
      }
    >;

    fillOrKillLimitOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "fillOrKillLimitOrder((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128)"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fillOrKillRfqOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "fillOrKillRfqOrder((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128)"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fillRfqOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        takerTokenFilledAmount: BigNumber;
        makerTokenFilledAmount: BigNumber;
      }
    >;

    "fillRfqOrder((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128)"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        takerTokenFilledAmount: BigNumber;
        makerTokenFilledAmount: BigNumber;
      }
    >;

    getLimitOrderHash(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<string>;

    "getLimitOrderHash((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256))"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<string>;

    getLimitOrderInfo(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<
      [string, number, BigNumber] & {
        orderHash: string;
        status: number;
        takerTokenFilledAmount: BigNumber;
      }
    >;

    "getLimitOrderInfo((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256))"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<
      [string, number, BigNumber] & {
        orderHash: string;
        status: number;
        takerTokenFilledAmount: BigNumber;
      }
    >;

    getLimitOrderRelevantState(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<
      [
        [string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        },
        BigNumber,
        boolean
      ] & {
        orderInfo: [string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        };
        actualFillableTakerTokenAmount: BigNumber;
        isSignatureValid: boolean;
      }
    >;

    "getLimitOrderRelevantState((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32))"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<
      [
        [string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        },
        BigNumber,
        boolean
      ] & {
        orderInfo: [string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        };
        actualFillableTakerTokenAmount: BigNumber;
        isSignatureValid: boolean;
      }
    >;

    getMetaTransactionExecutedBlock(
      mtx: {
        signer: string;
        sender: string;
        minGasPrice: BigNumberish;
        maxGasPrice: BigNumberish;
        expirationTimeSeconds: BigNumberish;
        salt: BigNumberish;
        callData: BytesLike;
        value: BigNumberish;
        feeToken: string;
        feeAmount: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "getMetaTransactionExecutedBlock((address,address,uint256,uint256,uint256,uint256,bytes,uint256,address,uint256))"(
      mtx: {
        signer: string;
        sender: string;
        minGasPrice: BigNumberish;
        maxGasPrice: BigNumberish;
        expirationTimeSeconds: BigNumberish;
        salt: BigNumberish;
        callData: BytesLike;
        value: BigNumberish;
        feeToken: string;
        feeAmount: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getMetaTransactionHash(
      mtx: {
        signer: string;
        sender: string;
        minGasPrice: BigNumberish;
        maxGasPrice: BigNumberish;
        expirationTimeSeconds: BigNumberish;
        salt: BigNumberish;
        callData: BytesLike;
        value: BigNumberish;
        feeToken: string;
        feeAmount: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<string>;

    "getMetaTransactionHash((address,address,uint256,uint256,uint256,uint256,bytes,uint256,address,uint256))"(
      mtx: {
        signer: string;
        sender: string;
        minGasPrice: BigNumberish;
        maxGasPrice: BigNumberish;
        expirationTimeSeconds: BigNumberish;
        salt: BigNumberish;
        callData: BytesLike;
        value: BigNumberish;
        feeToken: string;
        feeAmount: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<string>;

    getMetaTransactionHashExecutedBlock(
      mtxHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "getMetaTransactionHashExecutedBlock(bytes32)"(
      mtxHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getProtocolFeeMultiplier(overrides?: CallOverrides): Promise<number>;

    "getProtocolFeeMultiplier()"(overrides?: CallOverrides): Promise<number>;

    getQuoteSigner(overrides?: CallOverrides): Promise<string>;

    "getQuoteSigner()"(overrides?: CallOverrides): Promise<string>;

    getRfqOrderHash(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<string>;

    "getRfqOrderHash((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256))"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<string>;

    getRfqOrderInfo(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<
      [string, number, BigNumber] & {
        orderHash: string;
        status: number;
        takerTokenFilledAmount: BigNumber;
      }
    >;

    "getRfqOrderInfo((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256))"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<
      [string, number, BigNumber] & {
        orderHash: string;
        status: number;
        takerTokenFilledAmount: BigNumber;
      }
    >;

    getRfqOrderRelevantState(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<
      [
        [string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        },
        BigNumber,
        boolean
      ] & {
        orderInfo: [string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        };
        actualFillableTakerTokenAmount: BigNumber;
        isSignatureValid: boolean;
      }
    >;

    "getRfqOrderRelevantState((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32))"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<
      [
        [string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        },
        BigNumber,
        boolean
      ] & {
        orderInfo: [string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        };
        actualFillableTakerTokenAmount: BigNumber;
        isSignatureValid: boolean;
      }
    >;

    getRollbackEntryAtIndex(
      selector: BytesLike,
      idx: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    "getRollbackEntryAtIndex(bytes4,uint256)"(
      selector: BytesLike,
      idx: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    getRollbackLength(
      selector: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "getRollbackLength(bytes4)"(
      selector: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getTransformWallet(overrides?: CallOverrides): Promise<string>;

    "getTransformWallet()"(overrides?: CallOverrides): Promise<string>;

    getTransformerDeployer(overrides?: CallOverrides): Promise<string>;

    "getTransformerDeployer()"(overrides?: CallOverrides): Promise<string>;

    migrate(
      target: string,
      data: BytesLike,
      newOwner: string,
      overrides?: CallOverrides
    ): Promise<void>;

    "migrate(address,bytes,address)"(
      target: string,
      data: BytesLike,
      newOwner: string,
      overrides?: CallOverrides
    ): Promise<void>;

    multiHopFill(
      fillData: {
        tokens: string[];
        sellAmount: BigNumberish;
        calls: { selector: BytesLike; data: BytesLike }[];
      },
      minBuyAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "multiHopFill((address[],uint256,tuple[]),uint256)"(
      fillData: {
        tokens: string[];
        sellAmount: BigNumberish;
        calls: { selector: BytesLike; data: BytesLike }[];
      },
      minBuyAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<string>;

    "owner()"(overrides?: CallOverrides): Promise<string>;

    registerAllowedRfqOrigins(
      origins: string[],
      allowed: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    "registerAllowedRfqOrigins(address[],bool)"(
      origins: string[],
      allowed: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    rollback(
      selector: BytesLike,
      targetImpl: string,
      overrides?: CallOverrides
    ): Promise<void>;

    "rollback(bytes4,address)"(
      selector: BytesLike,
      targetImpl: string,
      overrides?: CallOverrides
    ): Promise<void>;

    sellToLiquidityProvider(
      inputToken: string,
      outputToken: string,
      provider: string,
      recipient: string,
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish,
      auxiliaryData: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "sellToLiquidityProvider(address,address,address,address,uint256,uint256,bytes)"(
      inputToken: string,
      outputToken: string,
      provider: string,
      recipient: string,
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish,
      auxiliaryData: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    sellToPancakeSwap(
      tokens: string[],
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish,
      fork: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "sellToPancakeSwap(address[],uint256,uint256,uint8)"(
      tokens: string[],
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish,
      fork: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    sellToUniswap(
      tokens: string[],
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish,
      isSushi: boolean,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "sellToUniswap(address[],uint256,uint256,bool)"(
      tokens: string[],
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish,
      isSushi: boolean,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    setQuoteSigner(
      quoteSigner: string,
      overrides?: CallOverrides
    ): Promise<void>;

    "setQuoteSigner(address)"(
      quoteSigner: string,
      overrides?: CallOverrides
    ): Promise<void>;

    setTransformerDeployer(
      transformerDeployer: string,
      overrides?: CallOverrides
    ): Promise<void>;

    "setTransformerDeployer(address)"(
      transformerDeployer: string,
      overrides?: CallOverrides
    ): Promise<void>;

    transferOwnership(
      newOwner: string,
      overrides?: CallOverrides
    ): Promise<void>;

    "transferOwnership(address)"(
      newOwner: string,
      overrides?: CallOverrides
    ): Promise<void>;

    transferProtocolFeesForPools(
      poolIds: BytesLike[],
      overrides?: CallOverrides
    ): Promise<void>;

    "transferProtocolFeesForPools(bytes32[])"(
      poolIds: BytesLike[],
      overrides?: CallOverrides
    ): Promise<void>;

    transformERC20(
      inputToken: string,
      outputToken: string,
      inputTokenAmount: BigNumberish,
      minOutputTokenAmount: BigNumberish,
      transformations: { deploymentNonce: BigNumberish; data: BytesLike }[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "transformERC20(address,address,uint256,uint256,tuple[])"(
      inputToken: string,
      outputToken: string,
      inputTokenAmount: BigNumberish,
      minOutputTokenAmount: BigNumberish,
      transformations: { deploymentNonce: BigNumberish; data: BytesLike }[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  filters: {
    ExpiredRfqOrder(
      orderHash: null,
      maker: null,
      expiry: null
    ): TypedEventFilter<
      [string, string, BigNumber],
      { orderHash: string; maker: string; expiry: BigNumber }
    >;

    LimitOrderFilled(
      orderHash: null,
      maker: null,
      taker: null,
      feeRecipient: null,
      makerToken: null,
      takerToken: null,
      takerTokenFilledAmount: null,
      makerTokenFilledAmount: null,
      takerTokenFeeFilledAmount: null,
      protocolFeePaid: null,
      pool: null
    ): TypedEventFilter<
      [
        string,
        string,
        string,
        string,
        string,
        string,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        string
      ],
      {
        orderHash: string;
        maker: string;
        taker: string;
        feeRecipient: string;
        makerToken: string;
        takerToken: string;
        takerTokenFilledAmount: BigNumber;
        makerTokenFilledAmount: BigNumber;
        takerTokenFeeFilledAmount: BigNumber;
        protocolFeePaid: BigNumber;
        pool: string;
      }
    >;

    LiquidityProviderSwap(
      inputToken: null,
      outputToken: null,
      inputTokenAmount: null,
      outputTokenAmount: null,
      provider: null,
      recipient: null
    ): TypedEventFilter<
      [string, string, BigNumber, BigNumber, string, string],
      {
        inputToken: string;
        outputToken: string;
        inputTokenAmount: BigNumber;
        outputTokenAmount: BigNumber;
        provider: string;
        recipient: string;
      }
    >;

    MetaTransactionExecuted(
      hash: null,
      selector: BytesLike | null,
      signer: null,
      sender: null
    ): TypedEventFilter<
      [string, string, string, string],
      { hash: string; selector: string; signer: string; sender: string }
    >;

    Migrated(
      caller: null,
      migrator: null,
      newOwner: null
    ): TypedEventFilter<
      [string, string, string],
      { caller: string; migrator: string; newOwner: string }
    >;

    OrderCancelled(
      orderHash: null,
      maker: null
    ): TypedEventFilter<[string, string], { orderHash: string; maker: string }>;

    OwnershipTransferred(
      previousOwner: string | null,
      newOwner: string | null
    ): TypedEventFilter<
      [string, string],
      { previousOwner: string; newOwner: string }
    >;

    PairCancelledLimitOrders(
      maker: null,
      makerToken: null,
      takerToken: null,
      minValidSalt: null
    ): TypedEventFilter<
      [string, string, string, BigNumber],
      {
        maker: string;
        makerToken: string;
        takerToken: string;
        minValidSalt: BigNumber;
      }
    >;

    PairCancelledRfqOrders(
      maker: null,
      makerToken: null,
      takerToken: null,
      minValidSalt: null
    ): TypedEventFilter<
      [string, string, string, BigNumber],
      {
        maker: string;
        makerToken: string;
        takerToken: string;
        minValidSalt: BigNumber;
      }
    >;

    ProxyFunctionUpdated(
      selector: BytesLike | null,
      oldImpl: null,
      newImpl: null
    ): TypedEventFilter<
      [string, string, string],
      { selector: string; oldImpl: string; newImpl: string }
    >;

    QuoteSignerUpdated(
      quoteSigner: null
    ): TypedEventFilter<[string], { quoteSigner: string }>;

    RfqOrderFilled(
      orderHash: null,
      maker: null,
      taker: null,
      makerToken: null,
      takerToken: null,
      takerTokenFilledAmount: null,
      makerTokenFilledAmount: null,
      pool: null
    ): TypedEventFilter<
      [string, string, string, string, string, BigNumber, BigNumber, string],
      {
        orderHash: string;
        maker: string;
        taker: string;
        makerToken: string;
        takerToken: string;
        takerTokenFilledAmount: BigNumber;
        makerTokenFilledAmount: BigNumber;
        pool: string;
      }
    >;

    RfqOrderOriginsAllowed(
      origin: null,
      addrs: null,
      allowed: null
    ): TypedEventFilter<
      [string, string[], boolean],
      { origin: string; addrs: string[]; allowed: boolean }
    >;

    TransformedERC20(
      taker: string | null,
      inputToken: null,
      outputToken: null,
      inputTokenAmount: null,
      outputTokenAmount: null
    ): TypedEventFilter<
      [string, string, string, BigNumber, BigNumber],
      {
        taker: string;
        inputToken: string;
        outputToken: string;
        inputTokenAmount: BigNumber;
        outputTokenAmount: BigNumber;
      }
    >;

    TransformerDeployerUpdated(
      transformerDeployer: null
    ): TypedEventFilter<[string], { transformerDeployer: string }>;
  };

  estimateGas: {
    _fillLimitOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      taker: string,
      sender: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "_fillLimitOrder((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128,address,address)"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      taker: string,
      sender: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    _fillRfqOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      taker: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "_fillRfqOrder((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128,address)"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      taker: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    _transformERC20(
      args: {
        taker: string;
        inputToken: string;
        outputToken: string;
        inputTokenAmount: BigNumberish;
        minOutputTokenAmount: BigNumberish;
        transformations: { deploymentNonce: BigNumberish; data: BytesLike }[];
      },
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "_transformERC20((address,address,address,uint256,uint256,tuple[]))"(
      args: {
        taker: string;
        inputToken: string;
        outputToken: string;
        inputTokenAmount: BigNumberish;
        minOutputTokenAmount: BigNumberish;
        transformations: { deploymentNonce: BigNumberish; data: BytesLike }[];
      },
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    batchCancelLimitOrders(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "batchCancelLimitOrders(tuple[])"(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    batchCancelPairLimitOrders(
      makerTokens: string[],
      takerTokens: string[],
      minValidSalts: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "batchCancelPairLimitOrders(address[],address[],uint256[])"(
      makerTokens: string[],
      takerTokens: string[],
      minValidSalts: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    batchCancelPairRfqOrders(
      makerTokens: string[],
      takerTokens: string[],
      minValidSalts: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "batchCancelPairRfqOrders(address[],address[],uint256[])"(
      makerTokens: string[],
      takerTokens: string[],
      minValidSalts: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    batchCancelRfqOrders(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "batchCancelRfqOrders(tuple[])"(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    batchExecuteMetaTransactions(
      mtxs: {
        signer: string;
        sender: string;
        minGasPrice: BigNumberish;
        maxGasPrice: BigNumberish;
        expirationTimeSeconds: BigNumberish;
        salt: BigNumberish;
        callData: BytesLike;
        value: BigNumberish;
        feeToken: string;
        feeAmount: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "batchExecuteMetaTransactions(tuple[],tuple[])"(
      mtxs: {
        signer: string;
        sender: string;
        minGasPrice: BigNumberish;
        maxGasPrice: BigNumberish;
        expirationTimeSeconds: BigNumberish;
        salt: BigNumberish;
        callData: BytesLike;
        value: BigNumberish;
        feeToken: string;
        feeAmount: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    batchFill(
      fillData: {
        inputToken: string;
        outputToken: string;
        sellAmount: BigNumberish;
        calls: {
          selector: BytesLike;
          sellAmount: BigNumberish;
          data: BytesLike;
        }[];
      },
      minBuyAmount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "batchFill((address,address,uint256,tuple[]),uint256)"(
      fillData: {
        inputToken: string;
        outputToken: string;
        sellAmount: BigNumberish;
        calls: {
          selector: BytesLike;
          sellAmount: BigNumberish;
          data: BytesLike;
        }[];
      },
      minBuyAmount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    batchFillLimitOrders(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      takerTokenFillAmounts: BigNumberish[],
      revertIfIncomplete: boolean,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "batchFillLimitOrders(tuple[],tuple[],uint128[],bool)"(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      takerTokenFillAmounts: BigNumberish[],
      revertIfIncomplete: boolean,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    batchFillRfqOrders(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      takerTokenFillAmounts: BigNumberish[],
      revertIfIncomplete: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "batchFillRfqOrders(tuple[],tuple[],uint128[],bool)"(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      takerTokenFillAmounts: BigNumberish[],
      revertIfIncomplete: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    batchGetLimitOrderRelevantStates(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "batchGetLimitOrderRelevantStates(tuple[],tuple[])"(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    batchGetRfqOrderRelevantStates(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "batchGetRfqOrderRelevantStates(tuple[],tuple[])"(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    cancelLimitOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "cancelLimitOrder((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256))"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    cancelPairLimitOrders(
      makerToken: string,
      takerToken: string,
      minValidSalt: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "cancelPairLimitOrders(address,address,uint256)"(
      makerToken: string,
      takerToken: string,
      minValidSalt: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    cancelPairRfqOrders(
      makerToken: string,
      takerToken: string,
      minValidSalt: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "cancelPairRfqOrders(address,address,uint256)"(
      makerToken: string,
      takerToken: string,
      minValidSalt: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    cancelRfqOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "cancelRfqOrder((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256))"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    createTransformWallet(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "createTransformWallet()"(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    executeMetaTransaction(
      mtx: {
        signer: string;
        sender: string;
        minGasPrice: BigNumberish;
        maxGasPrice: BigNumberish;
        expirationTimeSeconds: BigNumberish;
        salt: BigNumberish;
        callData: BytesLike;
        value: BigNumberish;
        feeToken: string;
        feeAmount: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "executeMetaTransaction((address,address,uint256,uint256,uint256,uint256,bytes,uint256,address,uint256),(uint8,uint8,bytes32,bytes32))"(
      mtx: {
        signer: string;
        sender: string;
        minGasPrice: BigNumberish;
        maxGasPrice: BigNumberish;
        expirationTimeSeconds: BigNumberish;
        salt: BigNumberish;
        callData: BytesLike;
        value: BigNumberish;
        feeToken: string;
        feeAmount: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    extend(
      selector: BytesLike,
      impl: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "extend(bytes4,address)"(
      selector: BytesLike,
      impl: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    fillLimitOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "fillLimitOrder((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128)"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    fillOrKillLimitOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "fillOrKillLimitOrder((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128)"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    fillOrKillRfqOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "fillOrKillRfqOrder((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128)"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    fillRfqOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "fillRfqOrder((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128)"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    getLimitOrderHash(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "getLimitOrderHash((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256))"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getLimitOrderInfo(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "getLimitOrderInfo((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256))"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getLimitOrderRelevantState(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "getLimitOrderRelevantState((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32))"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getMetaTransactionExecutedBlock(
      mtx: {
        signer: string;
        sender: string;
        minGasPrice: BigNumberish;
        maxGasPrice: BigNumberish;
        expirationTimeSeconds: BigNumberish;
        salt: BigNumberish;
        callData: BytesLike;
        value: BigNumberish;
        feeToken: string;
        feeAmount: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "getMetaTransactionExecutedBlock((address,address,uint256,uint256,uint256,uint256,bytes,uint256,address,uint256))"(
      mtx: {
        signer: string;
        sender: string;
        minGasPrice: BigNumberish;
        maxGasPrice: BigNumberish;
        expirationTimeSeconds: BigNumberish;
        salt: BigNumberish;
        callData: BytesLike;
        value: BigNumberish;
        feeToken: string;
        feeAmount: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getMetaTransactionHash(
      mtx: {
        signer: string;
        sender: string;
        minGasPrice: BigNumberish;
        maxGasPrice: BigNumberish;
        expirationTimeSeconds: BigNumberish;
        salt: BigNumberish;
        callData: BytesLike;
        value: BigNumberish;
        feeToken: string;
        feeAmount: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "getMetaTransactionHash((address,address,uint256,uint256,uint256,uint256,bytes,uint256,address,uint256))"(
      mtx: {
        signer: string;
        sender: string;
        minGasPrice: BigNumberish;
        maxGasPrice: BigNumberish;
        expirationTimeSeconds: BigNumberish;
        salt: BigNumberish;
        callData: BytesLike;
        value: BigNumberish;
        feeToken: string;
        feeAmount: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getMetaTransactionHashExecutedBlock(
      mtxHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "getMetaTransactionHashExecutedBlock(bytes32)"(
      mtxHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getProtocolFeeMultiplier(overrides?: CallOverrides): Promise<BigNumber>;

    "getProtocolFeeMultiplier()"(overrides?: CallOverrides): Promise<BigNumber>;

    getQuoteSigner(overrides?: CallOverrides): Promise<BigNumber>;

    "getQuoteSigner()"(overrides?: CallOverrides): Promise<BigNumber>;

    getRfqOrderHash(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "getRfqOrderHash((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256))"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getRfqOrderInfo(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "getRfqOrderInfo((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256))"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getRfqOrderRelevantState(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "getRfqOrderRelevantState((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32))"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getRollbackEntryAtIndex(
      selector: BytesLike,
      idx: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "getRollbackEntryAtIndex(bytes4,uint256)"(
      selector: BytesLike,
      idx: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getRollbackLength(
      selector: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "getRollbackLength(bytes4)"(
      selector: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getTransformWallet(overrides?: CallOverrides): Promise<BigNumber>;

    "getTransformWallet()"(overrides?: CallOverrides): Promise<BigNumber>;

    getTransformerDeployer(overrides?: CallOverrides): Promise<BigNumber>;

    "getTransformerDeployer()"(overrides?: CallOverrides): Promise<BigNumber>;

    migrate(
      target: string,
      data: BytesLike,
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "migrate(address,bytes,address)"(
      target: string,
      data: BytesLike,
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    multiHopFill(
      fillData: {
        tokens: string[];
        sellAmount: BigNumberish;
        calls: { selector: BytesLike; data: BytesLike }[];
      },
      minBuyAmount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "multiHopFill((address[],uint256,tuple[]),uint256)"(
      fillData: {
        tokens: string[];
        sellAmount: BigNumberish;
        calls: { selector: BytesLike; data: BytesLike }[];
      },
      minBuyAmount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    "owner()"(overrides?: CallOverrides): Promise<BigNumber>;

    registerAllowedRfqOrigins(
      origins: string[],
      allowed: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "registerAllowedRfqOrigins(address[],bool)"(
      origins: string[],
      allowed: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    rollback(
      selector: BytesLike,
      targetImpl: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "rollback(bytes4,address)"(
      selector: BytesLike,
      targetImpl: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    sellToLiquidityProvider(
      inputToken: string,
      outputToken: string,
      provider: string,
      recipient: string,
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish,
      auxiliaryData: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "sellToLiquidityProvider(address,address,address,address,uint256,uint256,bytes)"(
      inputToken: string,
      outputToken: string,
      provider: string,
      recipient: string,
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish,
      auxiliaryData: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    sellToPancakeSwap(
      tokens: string[],
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish,
      fork: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "sellToPancakeSwap(address[],uint256,uint256,uint8)"(
      tokens: string[],
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish,
      fork: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    sellToUniswap(
      tokens: string[],
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish,
      isSushi: boolean,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "sellToUniswap(address[],uint256,uint256,bool)"(
      tokens: string[],
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish,
      isSushi: boolean,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    setQuoteSigner(
      quoteSigner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "setQuoteSigner(address)"(
      quoteSigner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    setTransformerDeployer(
      transformerDeployer: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "setTransformerDeployer(address)"(
      transformerDeployer: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "transferOwnership(address)"(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    transferProtocolFeesForPools(
      poolIds: BytesLike[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "transferProtocolFeesForPools(bytes32[])"(
      poolIds: BytesLike[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    transformERC20(
      inputToken: string,
      outputToken: string,
      inputTokenAmount: BigNumberish,
      minOutputTokenAmount: BigNumberish,
      transformations: { deploymentNonce: BigNumberish; data: BytesLike }[],
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "transformERC20(address,address,uint256,uint256,tuple[])"(
      inputToken: string,
      outputToken: string,
      inputTokenAmount: BigNumberish,
      minOutputTokenAmount: BigNumberish,
      transformations: { deploymentNonce: BigNumberish; data: BytesLike }[],
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    _fillLimitOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      taker: string,
      sender: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "_fillLimitOrder((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128,address,address)"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      taker: string,
      sender: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    _fillRfqOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      taker: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "_fillRfqOrder((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128,address)"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      taker: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    _transformERC20(
      args: {
        taker: string;
        inputToken: string;
        outputToken: string;
        inputTokenAmount: BigNumberish;
        minOutputTokenAmount: BigNumberish;
        transformations: { deploymentNonce: BigNumberish; data: BytesLike }[];
      },
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "_transformERC20((address,address,address,uint256,uint256,tuple[]))"(
      args: {
        taker: string;
        inputToken: string;
        outputToken: string;
        inputTokenAmount: BigNumberish;
        minOutputTokenAmount: BigNumberish;
        transformations: { deploymentNonce: BigNumberish; data: BytesLike }[];
      },
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    batchCancelLimitOrders(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "batchCancelLimitOrders(tuple[])"(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    batchCancelPairLimitOrders(
      makerTokens: string[],
      takerTokens: string[],
      minValidSalts: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "batchCancelPairLimitOrders(address[],address[],uint256[])"(
      makerTokens: string[],
      takerTokens: string[],
      minValidSalts: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    batchCancelPairRfqOrders(
      makerTokens: string[],
      takerTokens: string[],
      minValidSalts: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "batchCancelPairRfqOrders(address[],address[],uint256[])"(
      makerTokens: string[],
      takerTokens: string[],
      minValidSalts: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    batchCancelRfqOrders(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "batchCancelRfqOrders(tuple[])"(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    batchExecuteMetaTransactions(
      mtxs: {
        signer: string;
        sender: string;
        minGasPrice: BigNumberish;
        maxGasPrice: BigNumberish;
        expirationTimeSeconds: BigNumberish;
        salt: BigNumberish;
        callData: BytesLike;
        value: BigNumberish;
        feeToken: string;
        feeAmount: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "batchExecuteMetaTransactions(tuple[],tuple[])"(
      mtxs: {
        signer: string;
        sender: string;
        minGasPrice: BigNumberish;
        maxGasPrice: BigNumberish;
        expirationTimeSeconds: BigNumberish;
        salt: BigNumberish;
        callData: BytesLike;
        value: BigNumberish;
        feeToken: string;
        feeAmount: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    batchFill(
      fillData: {
        inputToken: string;
        outputToken: string;
        sellAmount: BigNumberish;
        calls: {
          selector: BytesLike;
          sellAmount: BigNumberish;
          data: BytesLike;
        }[];
      },
      minBuyAmount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "batchFill((address,address,uint256,tuple[]),uint256)"(
      fillData: {
        inputToken: string;
        outputToken: string;
        sellAmount: BigNumberish;
        calls: {
          selector: BytesLike;
          sellAmount: BigNumberish;
          data: BytesLike;
        }[];
      },
      minBuyAmount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    batchFillLimitOrders(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      takerTokenFillAmounts: BigNumberish[],
      revertIfIncomplete: boolean,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "batchFillLimitOrders(tuple[],tuple[],uint128[],bool)"(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      takerTokenFillAmounts: BigNumberish[],
      revertIfIncomplete: boolean,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    batchFillRfqOrders(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      takerTokenFillAmounts: BigNumberish[],
      revertIfIncomplete: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "batchFillRfqOrders(tuple[],tuple[],uint128[],bool)"(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      takerTokenFillAmounts: BigNumberish[],
      revertIfIncomplete: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    batchGetLimitOrderRelevantStates(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "batchGetLimitOrderRelevantStates(tuple[],tuple[])"(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    batchGetRfqOrderRelevantStates(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "batchGetRfqOrderRelevantStates(tuple[],tuple[])"(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    cancelLimitOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "cancelLimitOrder((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256))"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    cancelPairLimitOrders(
      makerToken: string,
      takerToken: string,
      minValidSalt: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "cancelPairLimitOrders(address,address,uint256)"(
      makerToken: string,
      takerToken: string,
      minValidSalt: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    cancelPairRfqOrders(
      makerToken: string,
      takerToken: string,
      minValidSalt: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "cancelPairRfqOrders(address,address,uint256)"(
      makerToken: string,
      takerToken: string,
      minValidSalt: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    cancelRfqOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "cancelRfqOrder((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256))"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    createTransformWallet(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "createTransformWallet()"(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    executeMetaTransaction(
      mtx: {
        signer: string;
        sender: string;
        minGasPrice: BigNumberish;
        maxGasPrice: BigNumberish;
        expirationTimeSeconds: BigNumberish;
        salt: BigNumberish;
        callData: BytesLike;
        value: BigNumberish;
        feeToken: string;
        feeAmount: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "executeMetaTransaction((address,address,uint256,uint256,uint256,uint256,bytes,uint256,address,uint256),(uint8,uint8,bytes32,bytes32))"(
      mtx: {
        signer: string;
        sender: string;
        minGasPrice: BigNumberish;
        maxGasPrice: BigNumberish;
        expirationTimeSeconds: BigNumberish;
        salt: BigNumberish;
        callData: BytesLike;
        value: BigNumberish;
        feeToken: string;
        feeAmount: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    extend(
      selector: BytesLike,
      impl: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "extend(bytes4,address)"(
      selector: BytesLike,
      impl: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    fillLimitOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "fillLimitOrder((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128)"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    fillOrKillLimitOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "fillOrKillLimitOrder((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128)"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    fillOrKillRfqOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "fillOrKillRfqOrder((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128)"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    fillRfqOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "fillRfqOrder((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128)"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    getLimitOrderHash(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "getLimitOrderHash((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256))"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getLimitOrderInfo(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "getLimitOrderInfo((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256))"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getLimitOrderRelevantState(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "getLimitOrderRelevantState((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32))"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getMetaTransactionExecutedBlock(
      mtx: {
        signer: string;
        sender: string;
        minGasPrice: BigNumberish;
        maxGasPrice: BigNumberish;
        expirationTimeSeconds: BigNumberish;
        salt: BigNumberish;
        callData: BytesLike;
        value: BigNumberish;
        feeToken: string;
        feeAmount: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "getMetaTransactionExecutedBlock((address,address,uint256,uint256,uint256,uint256,bytes,uint256,address,uint256))"(
      mtx: {
        signer: string;
        sender: string;
        minGasPrice: BigNumberish;
        maxGasPrice: BigNumberish;
        expirationTimeSeconds: BigNumberish;
        salt: BigNumberish;
        callData: BytesLike;
        value: BigNumberish;
        feeToken: string;
        feeAmount: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getMetaTransactionHash(
      mtx: {
        signer: string;
        sender: string;
        minGasPrice: BigNumberish;
        maxGasPrice: BigNumberish;
        expirationTimeSeconds: BigNumberish;
        salt: BigNumberish;
        callData: BytesLike;
        value: BigNumberish;
        feeToken: string;
        feeAmount: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "getMetaTransactionHash((address,address,uint256,uint256,uint256,uint256,bytes,uint256,address,uint256))"(
      mtx: {
        signer: string;
        sender: string;
        minGasPrice: BigNumberish;
        maxGasPrice: BigNumberish;
        expirationTimeSeconds: BigNumberish;
        salt: BigNumberish;
        callData: BytesLike;
        value: BigNumberish;
        feeToken: string;
        feeAmount: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getMetaTransactionHashExecutedBlock(
      mtxHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "getMetaTransactionHashExecutedBlock(bytes32)"(
      mtxHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getProtocolFeeMultiplier(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "getProtocolFeeMultiplier()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getQuoteSigner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "getQuoteSigner()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getRfqOrderHash(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "getRfqOrderHash((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256))"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getRfqOrderInfo(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "getRfqOrderInfo((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256))"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getRfqOrderRelevantState(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "getRfqOrderRelevantState((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32))"(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getRollbackEntryAtIndex(
      selector: BytesLike,
      idx: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "getRollbackEntryAtIndex(bytes4,uint256)"(
      selector: BytesLike,
      idx: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getRollbackLength(
      selector: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "getRollbackLength(bytes4)"(
      selector: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getTransformWallet(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "getTransformWallet()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getTransformerDeployer(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "getTransformerDeployer()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    migrate(
      target: string,
      data: BytesLike,
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "migrate(address,bytes,address)"(
      target: string,
      data: BytesLike,
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    multiHopFill(
      fillData: {
        tokens: string[];
        sellAmount: BigNumberish;
        calls: { selector: BytesLike; data: BytesLike }[];
      },
      minBuyAmount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "multiHopFill((address[],uint256,tuple[]),uint256)"(
      fillData: {
        tokens: string[];
        sellAmount: BigNumberish;
        calls: { selector: BytesLike; data: BytesLike }[];
      },
      minBuyAmount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "owner()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    registerAllowedRfqOrigins(
      origins: string[],
      allowed: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "registerAllowedRfqOrigins(address[],bool)"(
      origins: string[],
      allowed: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    rollback(
      selector: BytesLike,
      targetImpl: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "rollback(bytes4,address)"(
      selector: BytesLike,
      targetImpl: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    sellToLiquidityProvider(
      inputToken: string,
      outputToken: string,
      provider: string,
      recipient: string,
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish,
      auxiliaryData: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "sellToLiquidityProvider(address,address,address,address,uint256,uint256,bytes)"(
      inputToken: string,
      outputToken: string,
      provider: string,
      recipient: string,
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish,
      auxiliaryData: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    sellToPancakeSwap(
      tokens: string[],
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish,
      fork: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "sellToPancakeSwap(address[],uint256,uint256,uint8)"(
      tokens: string[],
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish,
      fork: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    sellToUniswap(
      tokens: string[],
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish,
      isSushi: boolean,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "sellToUniswap(address[],uint256,uint256,bool)"(
      tokens: string[],
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish,
      isSushi: boolean,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    setQuoteSigner(
      quoteSigner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "setQuoteSigner(address)"(
      quoteSigner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    setTransformerDeployer(
      transformerDeployer: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "setTransformerDeployer(address)"(
      transformerDeployer: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "transferOwnership(address)"(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    transferProtocolFeesForPools(
      poolIds: BytesLike[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "transferProtocolFeesForPools(bytes32[])"(
      poolIds: BytesLike[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    transformERC20(
      inputToken: string,
      outputToken: string,
      inputTokenAmount: BigNumberish,
      minOutputTokenAmount: BigNumberish,
      transformations: { deploymentNonce: BigNumberish; data: BytesLike }[],
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "transformERC20(address,address,uint256,uint256,tuple[])"(
      inputToken: string,
      outputToken: string,
      inputTokenAmount: BigNumberish,
      minOutputTokenAmount: BigNumberish,
      transformations: { deploymentNonce: BigNumberish; data: BytesLike }[],
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;
  };
}
